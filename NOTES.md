CozyFS is a serialization-friendly in-memory file system that supports crash recovery, transactions, and zero-copy operations. You can back it up with a memory-mapped file to
offer ACID guarantees.

**NOTE**: Some information here is outdated.

# Use Cases
The file sistem will only use the single large memory buffer provided by the user. The file system state does not depend on its position, so the buffer can be copied somewhere else and a new handle to it can be created with cozyfs_attach. All the state will stay the same. A consequence of this is the file system can be backed by a memory mapped file making it persistent, or shared between processes by using a shared memory buffer, or both.

# Concurrency
Concurrent access will be managed with a single lock

# Crash Recovery
It's possible for processes to crash when using the file system, causing it to stay in an invalid state. To avoid this, the user-provided memory is divided in two halves, each with one instance of the file system. One is read-only and used as backup. Once in a while, when the writeable half is in a consistent state, a flag is toggled atomically which instantly marks the previously writeable region as backup, inverting the roles of the two halves. The process then copies the contents of the backup in the newly writeable half and leaves the critical section. When a process crashes while using the file system (potentially leaving it in an invalid state) it will leave the lock acquired, causing the others to wait indefinitely. To avoid this, the lock is made with a timeout. It is free when either it's not set or it's expired. When a process enters the critical section because the lock expired, it means the writeable half is invalid and therefore continues from the backup. I was thinking of making the lock using a 64bit word containing either zero or the timeout UTC timestamp. The lock is acquired when the word contains a time in the future, and is released when it's either zero or a time in the past.

# Transactions
Internally, the file system splits the buffer into chunks. To make the state position-independant, all pointers are stored relative to the start of the buffer. Any time a process is reading or writing to the file system, it must convert the relative pointers to absolute. My idea is to use chunk indices as pointer, therefore I'll have a function ptr2chnk which converts the index to pointer. When a process starts a transaction, any chunk that is about to be modified is instead copied to keep the real one intact. When the transaction bit is set, the ptr2chnk copies any chunk it would return and returns the pointer to the copy, then the address to the copy (and the index of the original chunk) is stored in a process-local table. When the same pointer is resolved, the copy is returned again. This makes it so processes in a transaction can see their own modifications but others can't. If the process crashes, all modifications are lost. If the process rolls back the transaction, simply all copies are deallocated. If the process commits, it copies all chunk copies at once. If someone else modified the file system in the mean time, the chunks are freed and the transaction fails
